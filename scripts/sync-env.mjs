#!/usr/bin/env node
// Syncs root .env into per-package envs so you only edit one file.
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, '..');

const rootEnv = path.join(root, '.env');
const rootEnvExample = path.join(root, '.env.example');
const dbEnv = path.join(root, 'packages/db/.env');
const webEnvLocal = path.join(root, 'apps/web/.env.local');
const dbFileAbs = path.join(root, 'packages/db/dev.db');

function parseEnv(content) {
  const lines = content.split(/\r?\n/);
  const out = {};
  for (const line of lines) {
    if (!line || /^\s*#/.test(line)) continue;
    const m = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)\s*$/);
    if (!m) continue;
    let val = m[2];
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    out[m[1]] = val;
  }
  return out;
}

function formatEnv(obj, header) {
  const keys = Object.keys(obj);
  keys.sort();
  const lines = [header, ...keys.map(k => `${k}=${obj[k]}`)];
  return lines.join('\n') + '\n';
}

function ensureDir(filePath) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function loadRootEnv() {
  if (!fs.existsSync(rootEnv)) {
    if (fs.existsSync(rootEnvExample)) {
      fs.copyFileSync(rootEnvExample, rootEnv);
      console.log('Created .env from .env.example at repo root. Please fill it.');
    } else {
      fs.writeFileSync(rootEnv, '# Fill values as needed\n');
    }
  }
  const content = fs.readFileSync(rootEnv, 'utf8');
  return parseEnv(content);
}

function isSqlite(url) {
  return typeof url === 'string' && url.startsWith('file:');
}

function isAbsoluteFileUrl(url) {
  // file:// or file:/// are absolute; file:./ and file:../ are relative
  return /^file:\/\//.test(url) || /^file:\/\/\//.test(url) || /^file:\/[^.]/.test(url);
}

function writeDbEnv(vars) {
  const out = { ...vars };
  // Drop keys we explicitly do not propagate to db/.env
  const excludedKeys = ['NEXTAUTH_SECRET'];
  for (const key of excludedKeys) {
    delete out[key];
  }
  // Force absolute sqlite path so CLI and runtime use the same file
  if (!out.DATABASE_URL || isSqlite(out.DATABASE_URL)) {
    out.DATABASE_URL = `file:${dbFileAbs}`;
  }
  ensureDir(dbEnv);
  fs.writeFileSync(
    dbEnv,
    formatEnv(out, '# Auto-generated by scripts/sync-env.mjs (packages/db/.env)')
  );
}

function writeWebEnv(vars) {
  const out = { ...vars };
  // Drop keys we explicitly do not propagate
  delete out.NEXTAUTH_SECRET;
  // Force absolute sqlite path matching the db CLI path
  const sqliteDbAbsolute = `file:${dbFileAbs}`;
  // Do not force a default APP_URL; include only if provided in root .env
  if (!out.DATABASE_URL || isSqlite(out.DATABASE_URL)) {
    out.DATABASE_URL = sqliteDbAbsolute;
  }
  ensureDir(webEnvLocal);
  fs.writeFileSync(
    webEnvLocal,
    formatEnv(out, '# Auto-generated by scripts/sync-env.mjs (apps/web/.env.local)')
  );
}

const vars = loadRootEnv();
writeDbEnv(vars);
writeWebEnv(vars);
console.log('Synced env to packages/db/.env and apps/web/.env.local');
